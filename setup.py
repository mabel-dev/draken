"""Setup script for the Draken package.

This script handles the compilation and installation of the Draken Cython/Arrow
interoperability library. It:
- Configures Cython extensions for all vector types and core components
- Sets up platform-specific compilation flags and optimizations
- Manages dependencies and build requirements
- Configures SIMD support for optimal performance

The build process creates optimized Cython extensions that provide zero-copy
interoperability with Apache Arrow for high-performance columnar data processing.
"""
import glob
import os
import platform
from sysconfig import get_config_var

from Cython.Build import cythonize
from setuptools import Extension
from setuptools import find_packages
from setuptools import setup


def is_mac():  # pragma: no cover
    return platform.system().lower() == "darwin"


def is_win():  # pragma: no cover
    return platform.system().lower() == "windows"


LIBRARY = "draken"
CPP_COMPILE_FLAGS = ["-O3"]
C_COMPILE_FLAGS = ["-O3"]
if is_mac():
    CPP_COMPILE_FLAGS += ["-std=c++17"]
elif is_win():
    CPP_COMPILE_FLAGS += ["/std:c++17"]
else:
    CPP_COMPILE_FLAGS += ["-std=c++17", "-march=native", "-fvisibility=default"]
    C_COMPILE_FLAGS += ["-march=native", "-fvisibility=default"]

include_dirs = []
# Get the C++ include directory
includedir = get_config_var("INCLUDEDIR")
if includedir:
    include_dirs.append(os.path.join(includedir, "c++", "v1"))

# Get the Python include directory
includepy = get_config_var("INCLUDEPY")
if includepy:
    include_dirs.append(includepy)

# Check if paths exist
include_dirs = [p for p in include_dirs if os.path.exists(p)]

print("\033[38;2;255;85;85mInclude paths:\033[0m", include_dirs)


__author__ = "notset"
__version__ = "notset"
_status = None
VersionStatus = None
with open(f"{LIBRARY}/__version__.py", mode="r") as v:
    vers = v.read()
exec(vers)  # nosec

RELEASE_CANDIDATE = _status == VersionStatus.RELEASE
COMPILER_DIRECTIVES = {"language_level": "3"}
COMPILER_DIRECTIVES["profile"] = not RELEASE_CANDIDATE
COMPILER_DIRECTIVES["linetrace"] = not RELEASE_CANDIDATE

print(f"\033[38;2;255;85;85mBuilding Draken version:\033[0m {__version__}")
print(f"\033[38;2;255;85;85mStatus:\033[0m {_status}", "(rc)" if RELEASE_CANDIDATE else "")

# Auto-generate vector_implementations.pyx to include all individual .pyx files in the folder
# This ensures new files are automatically included when added
vectors_dir = "draken/vectors"
vectors_file = os.path.join(vectors_dir, "vector_implementations.pyx")

# Find all .pyx files in the vectors directory (excluding vector.pyx and vector_implementations.pyx itself)
vector_pyx_files = sorted([
    os.path.basename(f) for f in glob.glob(os.path.join(vectors_dir, "*.pyx"))
    if os.path.basename(f) not in ("vector.pyx", "vector_implementations.pyx", "arrow_vector.py")
])

# Generate the vector_implementations.pyx file with include directives
with open(vectors_file, 'w', encoding="UTF8") as f:
    f.write("""# cython: language_level=3
# cython: nonecheck=False
# cython: cdivision=True
# cython: initializedcheck=False
# cython: infer_types=True
# cython: wraparound=False
# cython: boundscheck=False

\"\"\"
Auto-generated consolidated vector_implementations module.
This file is automatically generated by setup.py and includes all individual
vector implementation files in the vectors directory.

DO NOT EDIT THIS FILE MANUALLY - it will be overwritten during build.
\"\"\"

# Common imports needed across all vector implementations
import ctypes
import pyarrow
import pyarrow.compute as pc

# Cython imports
from cpython.mem cimport PyMem_Malloc
from cpython.ref cimport PyObject
from cpython cimport Py_ssize_t

# Standard C types
from libc.stdint cimport int32_t, int64_t, int8_t, intptr_t, uint32_t, uint64_t, uint8_t
from libc.stdlib cimport malloc, free
from libc.string cimport memcpy

# Draken core imports
from draken.core.buffers cimport DrakenFixedBuffer, DRAKEN_BOOL, DRAKEN_INT64, DRAKEN_FLOAT64, DRAKEN_STRING, DRAKEN_DATE32, DRAKEN_TIMESTAMP, DRAKEN_TIME
from draken.core.fixed_vector cimport alloc_fixed_buffer, buf_dtype, buf_itemsize, buf_length, free_fixed_buffer
from draken.vectors.vector cimport Vector

# NULL_HASH constant for null hash entries (defined once here to avoid redeclaration in included files)
cdef uint64_t NULL_HASH = <uint64_t>0x9e3779b97f4a7c15

""")
    
    # Add include directives for each .pyx file
    for pyx_file in vector_pyx_files:
        f.write(f'include "{pyx_file}"\n')

print(f"\033[38;2;255;85;85mAuto-generated vector_implementations.pyx with {len(vector_pyx_files)} includes\033[0m")

with open("README.md", mode="r", encoding="UTF8") as rm:
    long_description = rm.read()

#try:
#    with open("requirements.txt", "r") as f:
#        required = f.read().splitlines()
#except:
#    with open(f"{LIBRARY}.egg-info/requires.txt", "r") as f:
#        required = f.read().splitlines()

extensions = [

    Extension(
        "draken.interop.arrow",
        sources=["draken/interop/arrow.pyx"],
        extra_compile_args=C_COMPILE_FLAGS,
        include_dirs=include_dirs + ["draken"],
        depends=[
            "draken/core/buffers.h",
            "draken/interop/arrow_c_data_interface.h"
        ],
    ),
    Extension(
        name="draken.vectors.vector",
        sources=["draken/vectors/vector.pyx"],
        extra_compile_args=C_COMPILE_FLAGS,
        include_dirs=include_dirs + ["draken"],
        depends=["draken/core/buffers.h"],
    ),
    # Consolidated vector implementations - compiles all vector types into single .so
    Extension(
        name="draken.vectors.vector_implementations",
        sources=[vectors_file],
        extra_compile_args=C_COMPILE_FLAGS,
        include_dirs=include_dirs + ["draken"],
        depends=["draken/core/buffers.h"],
    ),
    Extension(
        name="draken.morsels.morsel",
        sources=["draken/morsels/morsel.pyx"],
        extra_compile_args=C_COMPILE_FLAGS,
        include_dirs=include_dirs + ["draken"],
        depends=[
            "draken/core/buffers.h"
            "draken/morsels/morsel.h"
        ],
    ),

]

# Add SIMD support flags
machine = platform.machine().lower()
system = platform.system().lower()
if machine.startswith("arm") and not machine.startswith("aarch64"):
    if system != "darwin":
        CPP_COMPILE_FLAGS.append("-mfpu=neon")
elif "x86" in machine or "amd64" in machine:
    CPP_COMPILE_FLAGS.append("-mavx2")

setup_config = {
    "name": LIBRARY,
    "version": __version__,
    "description": "Cython compatibility layer for Arrow",
    "long_description": long_description,
    "long_description_content_type": "text/markdown",
    "maintainer": "@joocer",
    "author": __author__,
    "author_email": "justin.joyce@joocer.com",
    "packages": find_packages(include=[LIBRARY, f"{LIBRARY}.*"]),
    "python_requires": ">=3.9",
    "url": "https://github.com/mabel-dev/draken/",
#    "install_requires": required,
    "ext_modules": cythonize(extensions),
    "package_data": {
        "": ["*.pyx", "*.pxd"],
    },
    "compiler_directives": COMPILER_DIRECTIVES,
}

setup(**setup_config)
